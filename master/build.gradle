apply plugin: 'distribution'

/*
 * High-level idea:
 * Configure all the projects with:
 * 		- properites for java libraries versions used
 * 		- the repositories
 * 		- add a task to create the ProjectSkeleton (TODO: create a plugin)
 * 		- create an explicti dependency between jacocoTestReport and test. In this way when jacocoTestReport is run the test task is automatically run
 * 
 * Configuration for the master
 * 		- take care of distributions
 * 			- the main one (the default) will contain all the jars for each distributable project
 * 			- the allDist configuration will contain the artifact for all the sources (one jar)
 * 		- in extenson namespace create different list with projects. Filter the projects and obtain different list of projects for different type of tasks
 * 		- a new task of Type Jar for the distribution with one jar for all files
 * 		- create a master jacocoTestReport taht will take into account the relevant executionData and the relevant sourceSets (the relevant list are configured in the 'ext' namespace)
 * 		- create dependency between assemble and jacocoTestReport
 * 
 * 
 * IMPORTANT FOR DEBUGGING:
 * 	- jacocoTestReport it does not execute properly if an execution data file is missing (you will see that is skipped)
 * 	- jacoco is modifynt the test task of each project and ataches to it and generates the executionData when the test task is run
 * 	- jacocoTestReport uses the executionData to generate report. It also needs to be aware of the sources for which the execution data is generated
 * 
 */


allprojects{
	version="1.0";
	apply plugin:'java'
	apply plugin:'jacoco'
	ext{
		prefixFromMasterProject="bitae-";
		sfl4jVersion="1.7.12";
		groovyVersion="2.1.6";
		junitVersion="4.12";
		hamcrestVersion="1.3";
		dbUnitVersion="2.5.1";
		hsqldbVersion="2.3.3";
	}
	repositories {
		jcenter();
	}
	task createProjectSkeleton{
		doLast{
			//todo - allow for additional technologies as parameters
			//todo - create .gitignorefile
			def listOfPlugins=['java','groovy']
			listOfPlugins=listOfPlugins.findAll {p->project.getPluginManager().hasPlugin(p)}
			def listOfFolders=listOfPlugins.collect{p->
				def returnedElement=[]
				returnedElement<<project.sourceSets.collect{sSet->[sSet[p].srcDirs,sSet.resources.srcDirs]}
				returnedElement
			}
			listOfFolders=listOfFolders.flatten().toSet();
			listOfFolders.each{dir->
				if (!dir.exists()){
					if (!dir.mkdirs()){
						throw new RuntimeException("Cannot create directory: ["+dir.getAbsolutePath()+"]");
					}
				}
			}
		}
	}
	jacocoTestReport.dependsOn test
}

//Only Master project
configurations{
	allDist
}


ext{
	//logic to obtain a list of projects for which the artifacts are included in the distribution
	skippedProjectsJars=[project(":test-model"),project(":test-support"),/*project(":mappings")*/];
	projectsInDistribution=project.subprojects-skippedProjectsJars;
	//logic to identify all the classes and resources that are to be included in the jar
	filesInAllJar=project.configurations.allDist.artifacts.files;
	//projects from which to gather jacocoTestReport
	jacocoExecutionData=[project(":smart-deploy"),project(":surrogation"),project(":test-model")];
	jacocoSourceData=[project(":smart-deploy"),project(":surrogation"),project(":model")];
}

task allJar(type:Jar) {
	baseName=prefixFromMasterProject+"all";
	from projectsInDistribution*.sourceSets['main'].output
}

artifacts{
	allDist allJar
}

distributions{
	main{
		contents{
			baseName=prefixFromMasterProject+"separate-files";
			from projectsInDistribution*.configurations.archives.artifacts.files
		}
	}
	allInOne{
		contents{
			baseName=prefixFromMasterProject+"one-file";
			from filesInAllJar;
		}
	}
}

task testReport(type: TestReport) {
	evaluationDependsOnChildren()
	destinationDir = file("$buildDir/reports/allTests")
	// Include the results from the `test` task in all subprojects
	def lst=subprojects*.tasks.test
	reportOn lst
}

jacocoTestReport{
	evaluationDependsOnChildren()
	
	//gather all tasks from the childre projects
	jacocoExecutionData*.tasks.each{taskContainer->
		executionData taskContainer
	}
	
	//excludes the data form the current project
	executionData=executionData.minus files(project.test.jacoco.destinationFile)
	
	//adds the sources
	jacocoExecutionData*.sourceSets*.main.each{sSet->
		sourceSets sSet
	}
	//set output directory for report
	reports.html.destination "${buildDir}/reports/jacoco/html"
}



assemble.dependsOn testReport
assemble.dependsOn jacocoTestReport
projectsInDistribution*.jacocoTestReport.each{jacocoTask->
	rootProject.jacocoTestReport.dependsOn jacocoTask
}

